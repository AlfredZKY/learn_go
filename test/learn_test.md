# 程序为什么要测试
对于程序和软件来讲，尽早发现问题、修正问题其实非常重要

# go的测试种类
- 功能测试(test)
- 基准测试(benchmark,也称为性能测试)
- 实例测试(example)

# go对测试函数的名称和签名都有哪些规定
- 对于功能测试函数来说，其名称必须以Test为前缀，并且参数列表只应有一个*testing.T类型的参数声明
- 对于性能测试函数来说，其名称必须以Benchmark为前缀，并且唯一的参数类型必须是*testing.B类型的参数声明
- 对于实例测试函数来说，其名称必须以Example为前缀，但对函数的参数类表没有强制规定

# go test命令执行的主要测试流程是什么？
- 首先只有测试源码文件的名称对了，测试函数的名称和签名也对了，当我们运行go test命令时，其中的测试代码才有可能被运行
- go test命令在开始运行时，会先做一些准备工作，比如，确定内部需要用到的命令，检查我们指定的代码包或源码文件的有效性，以及判断我们给与的标记是否合法等
- 在准备工作顺利完成后，go test 命令就会针对每个被测试的代码包，依次地进行构建、执行代码包中符合要求的测试函数，清理临时文件，打印测试结果，这就是通常情况下的主要测试流程
- 为了加快测试速度，它通常会并发地对多个测试代码包进行功能测试，只不过，在最后打印测试结果的时候，它会依照我们给定的顺序逐个进行，让我们感觉到它是在串行地执行测试流程
- 由于并发的测试会让性能测试的结果存在偏差，所以性能测试一般都是串行进行的，更具体的说是在所有构建步骤都做完之后，go test命令才会真正地开始进行性能测试
- 下一个代码包性能测试的进行，总会等到上一个代码性能测试的结果打印完成之后才会开始，而且性能测试函数的执行也都是串行的。

# testing包中函数
- t.Log()和t.Logf()打印的是常规的测试日志，如果测试成功的话，就不会打印这类日志，加-v标记可以在结果中查看常规测试的日志。
- t.Fail()当前测试函数会继续执行下去，但是结果会显示该测试失败
- t.FailNow()当前测试函数会立即终止执行，后面的代码都没有执行机会

# go中进行性能测试的命令
- go test -bench=. -run=BenchmarkGetPrimes -v
  - 必须有-bench=.这个标记代表进行性能测试，该标记的值.代表需要执行任意名称的性能测试函数
  - -run=^$ -run用于表示执行那个性能测试函数 ^$代表不执行任何功能函数
  - 不加-run表示，代表执行所有代码包中的测试函数，以上标记值都可以用正则来表示
  - BenchmarkGetPrimes-6 代表单个性能测试的名称，并且当时用的最大P数量为6
    - 最大P数量相当于同时运行goroutine的逻辑CPU的最大个数，这里的逻辑CPU，也可以被称为CPU核心，但它并不等同于计算机中真正的CPU核心，只是go语言运行时系统内部的一个概念，代表着同时运行goroutine的能力，-cpu 来设置一个最大P数量的列表，以供命令在多次测试时使用
    - 一台CPU的核心的个数，意味着它能在同一时刻执行多少条程序指令，代表着它的并行处理程序指令的能力
  - BenchmarkGetPrimes-6的右边代表着被测试函数被执行的实际测试
    - go test命令在执行性能测试函数的时候会给它一个正整数，若该测试函数的唯一参数名称b,则该正整数就由b.N代表，例如：
      - `for i:=0;i<b.N;i++{`
        `GetPrimes(1000)`
        `}`
    - 在这里会迭代b.N次的循环中调用了GetPrimes函数，并给与它参数值1000. go test命令会先尝试把b.N设置为1，然后执行测试函数，如果测试函数的执行时间没有超过上限，此上限默认为1秒，那么命令就会改大b.N的值，然后再次执行测试函数，如此往复，直到这个时间大于或者等于上限为止 
    - 当某次执行的时间大于等于上限时，我们就说这是命令此次对该测试函数的最后一次执行，这是b.N的值就会被包含在测试结果中，也就是上述测试结果中的500000，它代表被测试函数的执行次数。
  -  2730 ns/op表明单次执行被测试函数的平均时间为2730纳秒，这其实就是通过将最后一侧执行测试函数时的执行时间，除以(被测函数的)执行次数得出的

# go进行命令行测试的参数说明 
[参数解析参考网址](https://golang.google.cn/cmd/go/#hdr-Testing_flags)  
性能测试函数的执行次数 = `-cpu`标记的值中正整数的个数 x `-count`标记的值 x 探索式执行中测试函数的实际执行次数
- -bench=. 执行性能测试函数的标记
- -run=性能测试函数名(可以使正则表达式)
- -v 打印出测试结果的详细信息
- -cpu=n 设置测试执行最大P数量的正整数的列表，以逗号分隔开
  - `BenchmarkGetPrimes        500000              3186 ns/op`
    `BenchmarkGetPrimes-2      500000              2804 ns/op`
    `BenchmarkGetPrimes-4      500000              2652 ns/op`
  - go test命令在准备的时候回读取-cpu标记的值，并把它转换为一个以int为元素类型的切片，我们称之为逻辑CPU切片，如果该命令发现我们并没有追加这个标记，那么就会让逻辑CPU切片只包含一个元素值，即最大P数量的默认值，也就是当前计算机CPU核心的实际数量
  - 当准备执行某个测试函数的时候，无论该函数是功能测试函数，还是性能测试函数，go test命令都会迭代逻辑CPU切片，并且每次在迭代时，先依据当前的元素值设置最大P数量，然后再去执行测试函数
- -parallel标记，设置同一个被测试代码包中的功能测试函数的最大并发执行测试次数(默认是P),对性能测试无效
- -count专门用于重复执行测试函数的，默认是为1，它的值必须大于等于0

# 性能测试函数中的计时器是做什么用的
testing.B类型有几个指针方法:StartTimer,StopTimer和ResetTimer，这些都是用于操作当前性能测试函数专属的计时器
所谓计时器：是一个逻辑上的概念，它其实是testing.B类型中一些字段的统称
这些字段用于记录:当前测试函数在当次执行过程中耗费的时间，分配的堆内存的字节数以及分配次数