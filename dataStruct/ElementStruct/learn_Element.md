# go的链表结构方法 
    - MoveBefore
    - MoveAfrer
    - MoveToFront
    - MoveToBack
    - Front
    - Back
    - InsertBefore
    - InsertAfter
    - PushFront
    - PushBack

# 链表为什么是开箱即用 
    - List和Element到哦是结构体类型，结构体类型有一个特点，那就它们的零值都会是拥有额定结构，但是没有任何定制化的  
        内容的值，相当于一个空壳。值中字段也都会被赋予各自类型的零值
    - 广义来讲，所谓零值就是只做了声明，但还未做初始化的变量被给予的缺省值，每个类型的零值都会依据该类行的特性而被设定

# Ring与List的区别在哪？  
    container/ring包中的Ring类型实现是一个循环链表，List在内部就是一个循环链表，它的根元素永远不会持有任何实际的元素值在，  
    而该元素的存在就是为了连接这个链表的首尾两端  
    List的零值就是只包含了根元素，但是不包含任何实际元素值的空链表，那么Ring和List在本质上都是循环链表，区别：
        - Ring类型的数据结构仅占由它自身可代表，而List类型则需要由它以及Element类型联合表示，这也是表示方式上的不同，也是结构复杂度上的不同
        - 一个Ring类型的值严格来讲，只代表了所属的循环链表中的一个元素，而List类型的值则代表了一个完整的链表，这是维度上的不同意
        - 在创建并初始化一个Ring值的时候，我们可以指定它包含的元素的数量，但是对于一个List值来说却不能这样做，循环链表一旦被创建，
          其长度是不可变的。这是两个代码包中的New函数在功能在功能上的不同，也是两个类型在初始化值方面的第一个不同
        - 仅通过`var r ring.Ring`语句声明的r将会是一个长度为1的循环链表，而List类型的零值则是一个长度为0的链表。但是List中根元素不会持有者 
            实际元素值，因此计算长度时不会包含它，这是两个类型在初始化值方面的第二个不同
        - Ring值的le方法的算法复杂度是O(N)的，而List值的Len方法的算法复杂度则是O(1)的这是两这在性能方面最显著的差别  

Go 语言标准库中很多结构体类型的程序实体都做到了开箱即用。这也是在编写可供别人使用的代码包（或者说程序库）时，我们推荐遵循的最佳实践之一