# 线程模型
将goroutine看作Go特有的应用线程，Go线程模型:  
- M:machine的缩写。一个M代表一个内核线程。或称"工作线程"  
- P:processor的缩写。一个P代表执行一个Go代码片段所必需的资源。或称"上下文环境"  
- G:goroutine的缩写。一个G代表一个Go代码片段，前者是对后者的一种封装。  

简单说来说，一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境(内核线程+上下文唤醒)，每个P都会包含一个可运行的G的队列(runq)。该队列中的G会被依次传递给与本地P关联的M，获得运行时机。

# channel 的转换
利用函数声明将双向通道转换为单向通道的做法，只能算是Go语言的语法糖，并且我们不能利用函数声明把单向通道转换成双向通道，这样会得到一个编译错误

# 非缓冲的channe 
如果初始化一个通道时将其容量设置为0，或者直接忽略对容量的设置，就会使该通道成为一个非缓冲通道，与以异步的方式传递传递元素值的缓冲通道不同，非缓冲通道只能同步地传递元素值
- happen after
    - 向非缓冲通道发送元素值的操作会被阻塞，直到至少有一个针对该通道的接受操作进行为止，该接受操作会先得到元素值的副本，然后在唤醒发送方所在的goroutine之后返回，也就是说，这时的接受操作会在对应的发送操作完成之前完成
    - 接受非缓冲通道元素值时会被阻塞，知道至少有一个针对该通道的发送发作进行为止。该发送操作会直接把元素值复制给对方，然后在唤醒接收方的goroutine之后返回，也就是说，这是的发送操作会在对应接受操作完成之前完成
