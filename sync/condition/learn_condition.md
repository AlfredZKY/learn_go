# 条件变量的作用
条件变量是基于互斥锁的，它必须有互斥锁的支撑才能发挥作用(从源码中得知)。  
条件变量并不被用来保护临界区和共享资源的，它是用于协调想要访问共享资源的那些线程的，当共享资源的状态发生变化时，它可以被用来通知互斥锁阻塞的线程 

# 条件变量如何与互斥锁配合使用
条件变量的初始化离不开互斥锁，并且它的方法有的也是基于互斥锁的
条件变量提供的方法有3个：
- 等待通知(wait)
- 单发通知(signal)
- 广播通知(broadcast)
我们在利用条件变量等待通知的时候，需要它基于的那个互斥锁保护下进行
而在打发通知或广播通知的时候，却恰恰相反，也就是说，需要在对应的互斥锁解锁之后再进行。

# 条件变量wait做了什么
- 为什么要先锁定条件变量基于的互斥锁，才能调用它的Wait方法？
  - 因为条件变量的Wait方法在阻塞当前的goroutine之前会解锁它基于的互斥锁，所以在调用该Wait方法之前我们必须先锁定那个互斥锁，否则在调用这个Wait方法时，就会引发panic
  - 当接收到通知时。该方法所在的goroutine就会被唤醒，并且该方法会立即尝试锁定该锁。
  
- 为什么要用for循环来包裹调用其Wait方法的表达式，用if语句不行吗？
  - if只会检查一次，而for可以进行多次检查，直到这个状态改变为止
    - 主要为了保险，如果一个goroutine因收到通知而被唤醒，但却发现共享资源的状态，依然不符合它的要求，那么应该再次调用条件变量的Wait方法，并继续等待下次通知的到来
    - 有多个goroutine在等待共享资源的同一种状态。
    - 共享资源可能有的状态不是两个，而是更多。
    - 有一种可能，共享资源的状态只有两个，并且每种状态都只有一个goroutine在关注，就像我们在主问题当中实现的那个例子那样，不过即使是那样，使用for循环语句仍然是有必要的。(在一些多 CPU 核心的计算机系统中，即使没有收到条件变量的通知，调用其Wait方法的 goroutine 也是有可能被唤醒的。这是由计算机硬件层面决定的，即使是操作系统（比如 Linux）本身提供的条件变量也会如此。)


条件变量的Wait方法主要做了四件事
  - 把调用它的goroutine(也就是当前的goroutine)加入到当前条件变量的通知队列中
  - 解锁当前的条件变量基于的互斥锁
  - 让当前的goroutine处于等待状态，等到通知到来时再决定是否唤醒它，此时，这个goroutine就会阻塞在调用这个Wait方法的哪行代码上
  - 如果通知到来并且决定唤醒这个goroutine,那么就在唤醒它之后重新锁定当前条件变量基于的互斥锁，自此之后，当前的goroutine就会继续执行后面的代码

# signal和broadcast的区别
- 相同
  - 都是用于发送通知的
- 不同
  - signal的通知只会唤醒一个因此而等待的goroutine
  - broadcast的通知会唤醒所有为此等待的goroutine
条件变量的Wait()方法总会把当前的goroutine添加到通知队列的队尾，而它的signal方法总会从通知队列的队首开始查找可被唤醒的goroutine，所以因signal方法的通知而唤醒的goroutine一定是最早等待的哪一个