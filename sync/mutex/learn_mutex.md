# 同步的用途
go用通讯的方式共享数据
问题：一旦数据被多个线程共享，那么就可能会产生争用和冲突的情况，这种情况被称为竞态条件，往往会破坏共享数据的一致性
- 避免多个线程在同一时刻操作同一个代码块
- 协调多个线程，以避免它们在同一时刻执行同一个代码块

# 互斥锁的使用事项
- 不要重复锁定互斥锁
- 不要忘记解锁互斥锁，必要时使用defer语句
- 不要对尚未锁定或者已解锁的互斥锁解锁
- 不要在多个函数之间直接传递互斥锁

# go中的死锁
所谓的死锁，指的就是当前程序中的主 goroutine，以及我们启用的那些 goroutine 都已经被阻塞。这些 goroutine 可以被统称为用户级的 goroutine。这就相当于整个程序都已经停滞不前了。
Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 goroutine 都处于等待状态，就会自行抛出一个带有如下信息的 panic：fatal error: all goroutines are asleep - deadlock!  
<font color = '#ff0000'>注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用recover函数对它们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。</font>


# 函数中不可以传入一个互斥锁做参数
如果你把一个互斥锁作为参数值传给了一个参数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何影响

# 读写锁与互斥锁有哪些异同
读写锁是读/写互斥锁的简称，在go中读写锁由sync.RWMutex类型的值代表，与sync.Mutex一样，也是开箱即用。
顾名思义，读写锁是把共享资源的"读操作"和"写操作"区别对待了，它可以对这两种操作施加不同程度的保护，换句话说，相比于互斥锁，读写锁可以实现更加细腻的控制访问。
一个读写锁实际上包含了两个锁，即:读锁和写锁。sync.RWMutex类型中Lock方法和UnLock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。另外，对于同一个读写锁来说有如下规则：
- 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine
- 在写锁已被锁定的情况下试图锁定读锁，会阻塞当前的goroutine
- 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine
- 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine
换个角度来说就是，对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。

对写锁进行解锁时，会唤醒"所有因试图锁定读锁，而被阻塞的goroutine"，并且，这通常会使他们都成功完成对读锁的锁定

对读锁进行解锁，只会在没有其他读锁锁定前提下，唤醒"因试图锁定写锁，而被阻塞的goroutine"，并且最终只有一个会被唤醒的goroutine能够成功完成对写锁的锁定，其他的goroutine还要在原处继续等待，至于是哪一个goroutine，那就要看谁的等待时间最长了