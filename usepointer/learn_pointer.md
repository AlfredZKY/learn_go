# go语言中哪些值是不可寻址的
- 常量的值
- 基本类型值的字面量
- 算术操作的结果值
- 对各种字面量的索引表达式和切片表达式的结果值,不过,对切片字面量的索引结果值是可寻址的
- 对字符串变量的索引表达式和切片表达式的结果值
- 对字典变量的索引表达式的结果值
- 函数字面量和方法字面量，以及对他们的调用表达式的结果值
- 结构体字面量的字段值，也就是对结构体字谜那辆的选择表达式的结果值
- 类型转换表达式的结果值
- 类型断言表达式的结果值
- 接受表达式的结果值

# 问题解析
- 常量的值
  - 常量的值总是会被存储到一个确切的内存区域中，并且这种值肯定是不可变的
  - 基本类型值的字面量也是一样，其实它们本就可以被视为常量，只不过没有任何标志符代表它们
  - 关键词不可变的,由于go中字符串值也是不可变的，所以对于一个字符串类型的变量来说，基于它的索引或切片的结果值也都时不可寻址的,因为即使拿到了这种值的内存地址,也改变不了什么
- 算术操作的结果属于一种临时结果
  - 在我们把这种结果值赋给任何变量或常量之前，即使能拿到它的内存地址也是没有任何意义的
  - 关键词是临时结果.这个关键词能被用来解释很多现象.我们可以把各种对值字面量施加的表达式的求值结果都看作是临时结果
  - go语言中表达式：
    - 用于获得某个元素的索引表达式
    - 用于获得某个切片(片段)的切片表达式
    - 用于访问某个字段的选择表达式
    - 用于调用某个函数或方法的调用表达式
    - 用于转换值的类型的类型转换表达式
    - 用于判断值的类型的类型断言表达式
    - 想通道发送元素值或从通道哪里接受元素值的接受表达式
- 切片字面量的切片结果值是不可寻址的，但是索引值是可寻址的，切片值底层都会持有一个底层数组，而这个底层数组中的每个元素值都是有一个确切的内存值的
- 针对数组值、切片值、字典值的字面量的表达式会产生一个临时结果，如果是数组类型或切片类型的变量，那么索引或切片的结果值就不属于临时结果了，是可寻址的。主要是因为变量的值本身就不是"临时的",对比而言，值字面量在还没有与任何变量绑定之前，我们无法以任何方式引用它，这就是临时值
- 通过对字典类型的变量施加索引表达式，得到的结果值不属于临时结果，可是，这样的值却是不可寻址的，原因是，字典中每个键-元素对的存储位置都可能会变化，而且这种变化是外界无法感知的。
  - 字典中总会有若干个哈希桶用于均匀地存储键-元素对。当满足一定条件时，字典可能会改变哈希桶的数量，并适时地把其中的键-元素对搬运到对应的新的哈希桶中。在这种情况下，获取字典中任何元素值的指针都是无意义的，也是不安全的。
  - 关键词不安全的,"不安全的"操作很可能会破坏程序的一致性，引发不可预知的错误,从而严重影响程序的功能和稳定性。
- 再来看函数。函数是go语言中是一等公民，所以我们可以把代表函数或方法的字面量或标识符赋给某个比变量、传给某个函数或者从某个函数传出。但是这样的函数和方法都是不可寻址的，
  - 一个原因，是函数就是代码，是不可变的。
  - 另一个原因，拿到指向一段代码的指针是不安全的，此外，对函数或方法的调用结果值也是不可寻址的，因为它们都属于临时结果。
  
# 总结
- 不可变的值不可寻址，常量、基本类型的值字面量、字符串变量的值、函数以及方法的字面量都是如此，其实这样规定也有安全性方面的考略
- 绝大多数被视为临时结果的值都是不可寻址的。算术操作的结果属于临时结果，针对值字面量的表达式结果值也属于临时结果，但有一个例外，对切片字面量的索引结果值虽然也属于临时结果，但确实不可寻址的。
- 若拿到某值的指针可能会破坏程序的一致性，那么就是不安全的，该值就不可寻址。由于字典的内部机制，对字典的索引结果值的取址操作都是不安全的。另外，获取由字面量或标识符代表的函数或方法的地址显然也是不安全的。