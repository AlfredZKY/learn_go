# 线程模型
将goroutine看作Go特有的应用线程，Go线程模型:  
- M:machine的缩写。一个M代表一个内核线程。或称"工作线程"  
- P:processor的缩写。一个P代表执行一个Go代码片段所必需的资源。或称"上下文环境"  
- G:goroutine的缩写。一个G代表一个Go代码片段，前者是对后者的一种封装。  

简单说来说，一个G的执行需要P和M的支持。一个M在与一个P关联之后，就形成了一个有效的G运行环境(内核线程+上下文唤醒)，每个P都会包含一个可运行的G的队列(runq)。该队列中的G会被依次传递给与本地P关联的M，获得运行时机。

# channel类型
    本省就是并发安全的，这也是go语言自带的，唯一一个可以满足并发安全性的类型，使用make函数即可创建通道

# channel 如何接受和发送值
    - 通道通过接受和发送操作符进行数据的传送
    - `<-` 接送操作符，使用时，要把变量写在左边即可

# 对于通道的发送和接受操作都有那些基本的特性
    - 对于同一个通道，发送操作直接是互斥的，接受操作也是互斥的  
        - go语言的运行时系统(以下简称运行时系统)只会执行同一个通道的任意发送操作中的某一个  
        - 元素值被完全复制进通道之后，其他针对该通道的发送操作才能被执行  
        - 类似的，在同一时刻，运行时系统也只会执行，同一个通道的任意个接受操作中的某一个
        - 直到这个元素值被完全移出该通道之后，其他针对该通道的接受操作才可能被执行，即使这些操作是并发执行  
        - 元素值从外界进入通道时会被复制，更具体地说，进入通道的并不是在接受操作符右边的那个元素值，而是它的副本    
        - 元素值在被移动时，实际上包含了两步：
            - 第一步生成正在通道中的这个元素值的副本，并准备给到接收方  
            - 第二步是删除在通道中这个元素值  

    - 发送操作和接受操作中对元素值的处理都是不可分割的  
        - 在执行发送和接受操作时。绝不会被打断  

    - 发送操作在完全完成之前会被阻塞，接受操作也是如此  
        - 在发送和接受操作完成之前，该操作会一直阻塞在哪里，也就是说，它之后的代码不会有执行的机会，直到该代码的阻塞解除
    
    结论：如此阻塞代码其实就是为了实现操作的互斥和元素值的完整性 

# 通道的错误使用而造成的阻塞  
    - 对于值为nil的通道，不论它的具体类型是什么，对于它的发送和接受操作都会永久地处于阻塞状态，它的goroutine的代码，不会执行
    注意:由于通道类型就是引用类型，所以它的零值就是nil,换句话说，当我们只声明该类型的变量但是没有用make对它进行初始化时，该变量的值就是nil,所以一定不要忘记初始化通道

# 通道什么时候会引发panic
    - 对于一个已经初始化，但是未关闭的通道来说，手法操作一定不会引发panic,但是通道一旦关闭，在对它进行发送操作，一定会引发panic
    - 当我们试图关闭一个已经关闭了的通道，也会引发panic,注意:接搜操作是可以感知到通道的关闭的，并能够安全退出的 
    - 接受表达式可以同时赋值给两个变量，第二个变量一定是bool类型，如果它的值为false，就说明通道关闭
    - 注意：如果通道关闭时，里面还有元素未取出，那么接受表达式的第一个结果仍会是通道中的元素值，第二个值一定是ture
        因此，通过接受表达式的第二个结果值，来判断通道是否关闭可能会有延迟
    综上所述：通道的关闭一定要让发送放来做

# channel 的转换
利用函数声明将双向通道转换为单向通道的做法，只能算是Go语言的语法糖，并且我们不能利用函数声明把单向通道转换成双向通道，这样会得到一个编译错误

# 非缓冲的channe 
如果初始化一个通道时将其容量设置为0，或者直接忽略对容量的设置，就会使该通道成为一个非缓冲通道，与以异步的方式传递传递元素值的缓冲通道不同，非缓冲通道只能同步地传递元素值
- happen after
    - 向非缓冲通道发送元素值的操作会被阻塞，直到至少有一个针对该通道的接受操作进行为止，该接受操作会先得到元素值的副本，然后在唤醒发送方所在的goroutine之后返回，也就是说，这时的接受操作会在对应的发送操作完成之前完成
    - 接受非缓冲通道元素值时会被阻塞，知道至少有一个针对该通道的发送发作进行为止。该发送操作会直接把元素值复制给对方，然后在唤醒接收方的goroutine之后返回，也就是说，这是的发送操作会在对应接受操作完成之前完成
