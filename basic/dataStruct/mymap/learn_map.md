# 字典
    - 它能存储的是键值对的集合，而不是单一值的集合,用于存储一系列无序的键值对，它基于键存储，键就像一个索引一样，可以快速检索数据  
    - 底层是哈希表的特定实现，键的类型受限，值却可以使任意类型
    - 内部实现
        Map是基于散列表来实现，就是我们常说的Hash表，所以我们每次迭代Map的时候打印的Key和Value是无序的，每次迭代都不一样
        Map的散列表包含一组桶，每次存储和查找键值对的时候，都要先选择一个桶，就是选择一个哈希函数，把指定的键传给散列函数，
        就可以所引到相应的桶了，进而找到对应的键值
    - 好处
        这种方式的好处，存储的数据越多，索引分布越均匀，索引我们访问键值对的速度也就越快，当然存储细节有很多，
        我们只要记住Map存储的是无序的键值对集合即可

# 字典的存储 
    - 字典通过底层的哈希表来进行某个元素的查找，我没那先把键值作为参数传给哈希表，哈希表会先用哈希函数把键值转化为哈希值 
    - 哈希值通常是一个无符号的整数，一个哈希表会持有一定数量的桶，也可以称为哈希桶，这些桶会均匀地存储其所属哈表收纳的那些键-元素对
    - 因此，哈希表会先用这个键的哈希值的低几位去定位到一个哈希桶，然后再去这个桶中查找这个键，由于键-元素对总是被捆绑在一起存储的，所以一旦找到了键，就一定能找到对应的元素值
    - 字典不会独立存储任何键的值，但会独立存储他们的哈希值 

# 字典的键的限制在 
    - go语言字典的键类型不可以是函数类型，字典类型和切片类型
    - go语言规定，在键类型的值之间必须可以施加操作符==和!=。换句话说，键类型的必须要支持判等操作。
    - 由于函数类型、字典类型、切片类型并不支持判等操作，字典的键类型不能是这里类型。

# 字典的查找
    - 每个哈希桶都会把自己所包含的键的哈希值存起来，go语言会用被查找键的哈希值与这些哈希值逐个对比，看看是否有相等的
    如果一个相等的，如果一个相等的都没有，那么就说明这个桶中没有要查找的键值，这是Go语言就会立刻返回结果了
    - 如果有相同的，那就再用键值本身去比对一次，因为不同值的哈希值可能相同的，这就叫做哈希碰撞
    - 所以，即使哈希值一样，键值也不一定一样，如果键类型值之间无法判断相等，那么此时这个映射的过程就没办法继续下去了，最后，只有键的哈希值和键值都相等，才能说明查找到了匹配的键-元素对

    - 影响字典查找的速度包含了哈希计算和判等
        - 求哈希时，宽度越小的类型，速度越快，对于字符串类型，长度越短，越快
        - 对于复杂类型，是对它的所有字段值求哈希值并进行合并，所以关键在于它各个字段的类型以及字段的数量
        - 对于接口类型，具体的哈希算法，则由值的实际类型决定
        - 在基本类型中优先选择数值类型和指针类型，通常情况下类型的宽度越小越好，字符串的话可以对键值长度进行约束