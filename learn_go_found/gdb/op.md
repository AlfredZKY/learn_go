# 使用gcc编译并使用gdb进行调试
`gcc main.c -o call` 
`gdb call` 

# 使用gdb进行反汇编调试
- 使用`info file` 
    - 可以看到代码和数据段已经程序的入口地址 

- 使用`disass func`
    - 查看func的反汇编代码，func代指函数名
        ```
            (gdb) disass main
            Dump of assembler code for function main:
            0x0000000100003f40 <+0>:     push   %rbp
            0x0000000100003f41 <+1>:     mov    %rsp,%rbp
            0x0000000100003f44 <+4>:     sub    $0x20,%rsp
            0x0000000100003f48 <+8>:     movl   $0x0,-0x4(%rbp)
            0x0000000100003f4f <+15>:    mov    %edi,-0x8(%rbp)
            0x0000000100003f52 <+18>:    mov    %rsi,-0x10(%rbp)
            0x0000000100003f56 <+22>:    mov    $0x1,%edi
            0x0000000100003f5b <+27>:    mov    $0x2,%esi
            0x0000000100003f60 <+32>:    call   0x100003f20 <sum>
            0x0000000100003f65 <+37>:    mov    %eax,-0x14(%rbp)
            0x0000000100003f68 <+40>:    mov    -0x14(%rbp),%esi
            0x0000000100003f6b <+43>:    lea    0x34(%rip),%rdi        # 0x100003fa6
            0x0000000100003f72 <+50>:    mov    $0x0,%al
            0x0000000100003f74 <+52>:    call   0x100003f86
            0x0000000100003f79 <+57>:    xor    %ecx,%ecx
            0x0000000100003f7b <+59>:    mov    %eax,-0x18(%rbp)
            0x0000000100003f7e <+62>:    mov    %ecx,%eax
            0x0000000100003f80 <+64>:    add    $0x20,%rsp
            0x0000000100003f84 <+68>:    pop    %rbp
            0x0000000100003f85 <+69>:    ret    
            End of assembler dump.
        ```
   
    - `b *0x0000000100003f40` 
        - 在地址0x0000000100003f40处打上断点后进行r运行
       
    - 再次对main函数进行反汇编操作
        - 反汇编代码
            ```
            =>  0x0000000100003f40 <+0>:     push   %rbp
                0x0000000100003f41 <+1>:     mov    %rsp,%rbp
                0x0000000100003f44 <+4>:     sub    $0x20,%rsp
                0x0000000100003f48 <+8>:     movl   $0x0,-0x4(%rbp)
                0x0000000100003f4f <+15>:    mov    %edi,-0x8(%rbp)
                0x0000000100003f52 <+18>:    mov    %rsi,-0x10(%rbp)
                0x0000000100003f56 <+22>:    mov    $0x1,%edi
                0x0000000100003f5b <+27>:    mov    $0x2,%esi
                0x0000000100003f60 <+32>:    call   0x100003f20 <sum>
                0x0000000100003f65 <+37>:    mov    %eax,-0x14(%rbp)
                0x0000000100003f68 <+40>:    mov    -0x14(%rbp),%esi
                0x0000000100003f6b <+43>:    lea    0x34(%rip),%rdi        # 0x100003fa6
                0x0000000100003f72 <+50>:    mov    $0x0,%al
                0x0000000100003f74 <+52>:    call   0x100003f86
                0x0000000100003f79 <+57>:    xor    %ecx,%ecx
                0x0000000100003f7b <+59>:    mov    %eax,-0x18(%rbp)
                0x0000000100003f7e <+62>:    mov    %ecx,%eax
                0x0000000100003f80 <+64>:    add    $0x20,%rsp
                0x0000000100003f84 <+68>:    pop    %rbp
                0x0000000100003f85 <+69>:    ret    
                End of assembler dump.
            ```

        - 寄存器的值  
            ```
            (gdb) i r rip rsp rbp
                rip            0x100003f40         0x100003f40 <main>
                rsp            0x7ffeefbffa98      0x7ffeefbffa98
                rbp            0x7ffeefbffaa0      0x7ffeefbffaa0
            ```
    - `b *0x0000000100003f40` 接着打断点后并继续执行
        - 反汇编代码
            ```
                0x0000000100003f40 <+0>:     push   %rbp
            => 0x0000000100003f41 <+1>:     mov    %rsp,%rbp
                0x0000000100003f44 <+4>:     sub    $0x20,%rsp
                0x0000000100003f48 <+8>:     movl   $0x0,-0x4(%rbp)
                0x0000000100003f4f <+15>:    mov    %edi,-0x8(%rbp)
                0x0000000100003f52 <+18>:    mov    %rsi,-0x10(%rbp)
                0x0000000100003f56 <+22>:    mov    $0x1,%edi
                0x0000000100003f5b <+27>:    mov    $0x2,%esi
                0x0000000100003f60 <+32>:    call   0x100003f20 <sum>
                0x0000000100003f65 <+37>:    mov    %eax,-0x14(%rbp)
                0x0000000100003f68 <+40>:    mov    -0x14(%rbp),%esi
                0x0000000100003f6b <+43>:    lea    0x34(%rip),%rdi        # 0x100003fa6
                0x0000000100003f72 <+50>:    mov    $0x0,%al
                0x0000000100003f74 <+52>:    call   0x100003f86
                0x0000000100003f79 <+57>:    xor    %ecx,%ecx
                0x0000000100003f7b <+59>:    mov    %eax,-0x18(%rbp)
                0x0000000100003f7e <+62>:    mov    %ecx,%eax
                0x0000000100003f80 <+64>:    add    $0x20,%rsp
                0x0000000100003f84 <+68>:    pop    %rbp
                0x0000000100003f85 <+69>:    ret    
            ```
        - 寄存器的值
            ```
                (gdb) i r rip rsp rbp
                rip            0x100003f41         0x100003f41 <main+1>
                rsp            0x7ffeefbffa90      0x7ffeefbffa90
                rbp            0x7ffeefbffaa0      0x7ffeefbffaa0
            ```
        - cpu会自动执行下一条指令
            执行push指令会修改rsp寄存器的值，但它并不会修改rip寄存器，为什么这里rip也变了呢？其实这是CPU自动完成的，CPU自己知道它要执行的每一条指令的长度有几个字节，比如这里的push %rbp指令只有1个字节长，于是它在开始执行这条指令时就会把rip的值+1，因为执行这条指令之前rip的值为0x100003f40，+1之后就变成了0x100003f41，也就是说它指向了main函数的第2条指令。



- 汇编指令说明
    - 例
        比如第一行代码 0x0000000100003f40 <+0>:	push   %rbp，表示main函数的第一条指令push %rbp在内存中的地址为0x0000000100003f40，偏移为0（因为它是main函数的第一条指令）
    - `=>  0x0000000100003f40 <+0>:     push   %rbp` 
        - "=>" 代表当前cpu执行指令的下一条指令，也就是rip寄存器的值
        - "0x0000000100003f40" 代表当前cpu执行指令的下一条指令的地址
        - "<+0>" 指令相对于当前函数起始地址以字节为单位的偏移
        - "push   %rbp" 指令操作

- 函数序言
    - 这3条指令我们一般称之为函数序言，基本上每个函数都以函数序言开始，其主要作用在于保存调用者的rbp寄存器以及为当前函数分配栈空间
        ```
        =>  0x0000000100003f40 <+0>:     push   %rbp
            0x0000000100003f41 <+1>:     mov    %rsp,%rbp
            0x0000000100003f44 <+4>:     sub    $0x20,%rsp
        ```

- 查看寄存器的值 
    ```
        (gdb) i r rip rsp rbp
        rip            0x100003f40         0x100003f40 <main>
        rsp            0x7ffeefbffa98      0x7ffeefbffa98
        rbp            0x7ffeefbffaa0      0x7ffeefbffaa0
    ```

- 汇编指令分析
    - 0x0000000100003f40 <+0>:    push   %rbp
        这条指令把栈基地址寄存器rbp的值临时保存在main函数的栈帧里，因为main函数需要使用这个寄存器来存放自己的栈基地址，而调用者在调用main函数之前也把它的栈基地址保存在了这个寄存器里面，所以main函数需要把这个寄存器里面的值先保存起来，等main执行完后返回时再把这个寄存器恢复原样，如果不恢复原样，main函数返回后调用者使用rbp寄存器时就会有问题，因为在执行调用者的代码时rbp本应该指向调用者的栈但现在却指向了main函数的栈。    

        在这条指令之前，代码还在使用调用者的栈帧，执行完这条指令之后，开始使用main函数的栈帧，目前main函数的栈帧里面只保存有调用者的rbp这一个值，
        rbp在main函数这里代表main函数要开启自己的函数的栈基址，并把上一个函数的栈基址入栈保存，当main函数执行完毕后，在跳回到上一个函数的调用。







# 常用的gdb命令
- info 查看指令
    - info b 查看断点
    - info r rip rsp rbp 查看寄存器 rip rsp rbp 的值

- b 下断点
    - b 行号 在该行号出下断点
    - b *地址 在该地址处下断点

- bt 查看函数栈的调用

- thread 查看多线程调用