# 解析汇编代码
- 0x0000:  
    - 当前指令相对于当前函数的偏移量  
- TEXT	"".add: 
    - TEXT指令声明了 "".add是.text段(程序代码在运行期间会放在内存的.text段中)的一部分，并表明跟在这个声明后的是函数的函数体。
    - 在链接期，""这个空字符会被替换为当前的包名，也就是说，"".add在链接到二进制会文件后会变成main.add
    - (SB):SB是一个虚拟寄存器，保存了静态基地址(static-base)指针，即我们程序地址空间的开始地址。"".add(SB)表明我们的符号位于某个固定的相对地址空间
        起始处的偏移位置(最终是由链接器计算得到的)换句话说，它有一个直接的绝对地址:是一个全局的函数符号。
        `objdump -j .text -t direct_topfunc_call | grep 'main.add' `
        - 所有的用户定义的符号都被写为相对于伪寄存器FP(参数以及局部值)和SB(全局值)的偏移量，SB伪寄存器可以被认为是内存起始的位置，所以对于符号foo(SB)就是名称foo在内存的地址

- $0-16:
    - 代表即将分配的栈帧大小，而$16指定了调用方传入的参数的大小
        - 通常来讲，帧大小后一般都跟随着一个参数大小，用减号分隔。(这不是一个减法操作，只是 一种特殊的语法)帧大小 $24-8 意味着这个函数有24个字节的帧以及8个字节的参数，位 于调用者的帧上。如果NOSPLIT没有在TEXT中指定，则必须提供参数大小。对于Go原型的 汇编函数，go vet会检查参数大小是否正确。    
    
-	0x0000 00000  FUNCDATA	$0, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)
- 	0x0000 00000  FUNCDATA	$1, gclocals·33cdeccccebe80329f1fdbee7f5874cb(SB)    
    - FUNCDATA以及PCDATA指令包含有被垃圾回收所使用的信息；这些指令是被编译器加入的。

-	0x0000 00000 MOVL	"".b+12(SP), AX
-	0x0004 00004 MOVL	"".a+8(SP), CX
    - go的调用规则要求每一个参数都通过栈传递，这部分空间有caller在其栈帧(stack frame)上提供
    - 调用其他过程之前，caller就需要按照参数和返回变量大小来对应地增长(返回后收缩)栈
    - Go 编译器不会生成任何 PUSH/POP 族的指令: 栈的增长和收缩是通过在栈指针寄存器 SP 上分别执行减法和加法指令来实现的。
    - SP伪寄存器是虚拟的栈指针，用于引用帧局部变量以及为函数调用准备的参数。 它指向局部栈帧的顶部，所以应用应该使用负的偏移且范围在[-framesize, 0): x-8(SP), y-4(SP), 等等。
    - "".b+12(SP) 和 "".a+8(SP) 分别指向栈的低12字节和8字节位置(记住:栈是向低位地址方向增长的) .a 和 .b是分配给引用地址的任意别名;尽管 他们没有任何语义上的含义，
        但在使用虚拟寄存器和相对地址时，这种别名是需要强制使用的

    - 有两个重点需要指出:
        - 第一个变量a的地址并不是0(SP),而是在8(SP);这是因为调用方通过call伪指令，把其返回地址保存在了0(SP)位置。
        - 参数是反序传入的，也就是第一个参数和栈顶距离最近

- 	0x0008 00008 ADDL	CX, AX
-	0x000a 00010 MOVL	AX, "".~r2+16(SP)
-	0x000e 00014 MOVB	$1, "".~r3+20(SP)
    - ADDL
        - 进行实际的加法操作，L这里代表Long,4字节的值，其将保存在CX和AX的值相加，然后保存进AX寄存器中，这个结果之后被移动到 "".~r2+16(SP)地址处
            这是之前调用方专门为返回值预留的栈空间。这一次"".~r同样没有什么语义上的含义

- 0x0013 00019 RET    
    - 为了演示 Go 如何处理多返回值，我们同时返回了一个 bool 常量 true。 返回这个 bool 值的方法和之前返回数值的方法是一样的；只是相对于 SP 寄存器的偏移量发生了变化。
    - 最后的 RET 伪指令告诉 Go 汇编器插入一些指令，这些指令是对应的目标平台中的调用规约所要求的，从子过程中返回时所需要的指令。 一般情况下这样的指令会使在 0(SP) 寄存器中保存的函数返回地址被 pop 出栈，并跳回到该地址。


- 0x000f 00015	SUBQ	$24, SP
- 0x0013 00019	MOVQ	BP, 16(SP)
- 0x0018 00024	LEAQ	16(SP), BP
    - 通过对虚拟栈指针(stack-pointer)寄存器做减法，将其栈帧大小增加了 24 个字节(回忆一下栈是向低地址方向增长，所以这里的 SUBQ 指令是将栈帧的大小调整得更大了)。 这 24 个字节中：
        - 8 个字节(16(SP)-24(SP)) 用来存储当前帧指针 BP (这是一个实际存在的寄存器)的值，以支持栈的展开和方便调试
        - 1+3 个字节(12(SP)-16(SP)) 是预留出的给第二个返回值 (bool) 的空间，除了类型本身的 1 个字节，在 amd64 平台上还额外需要 3 个字节来做对齐
        - 4 个字节(8(SP)-12(SP)) 预留给第一个返回值 (int32)
        - 4 个字节(4(SP)-8(SP)) 是预留给传给被调用函数的参数 b (int32)
        - 4 个字节(0(SP)-4(SP)) 预留给传入参数 a (int32)
    - 跟随栈的增长，LEAQ指令计算出栈帧指针的新地址，并将其存储到BP寄存器中



- 0x001d 00029 	MOVQ	$137438953482, AX
- 0x0027 00039 	MOVQ	AX, (SP)
    - 调用方将被调用方需要的参数作为一个Quad word(8字节值)推到了刚刚增长的栈的栈顶
    - 尽管指令里出现的 137438953482 这个值看起来像是随机的垃圾值，实际上这个值对应的就是 10 和 32 这两个 4 字节值，它们两被连接成了一个 8 字节值。
    - `echo 'obase=2;137438953482' | bc`

- 	0x002b 00043 	CALL	"".add(SB)
    - 我们使用相对于 static-base 指针的偏移量，来对 add 函数进行 CALL 调用: 这种调用实际上相当于直接跳到一个指定的地址。
    - 注意 CALL 指令还会将函数的返回地址(8 字节值)也推到栈顶；所以每次我们在 add 函数中引用 SP 寄存器的时候还需要额外偏移 8 个字节！ 例如，"".a 现在不是 0(SP) 了，而是在 8(SP) 位置。

- 0x0030 00048 MOVQ	16(SP), BP
- 0x0035 00053 ADDQ	$24, SP
- 0x0039 00057 RET
    - 将帧指针(frame-pointer)下降一个栈帧(stack-frame)的大小(就是“向下”一级)
    - 将栈收缩 24 个字节，回收之前分配的栈空间
    - 请求 Go 汇编器插入子过程返回相关的指令