# 规则如下面所示
- 对于每一个case表达式，都至少会包含一个代表发送操作的发送表达式或者一个代表接收操作的接收表达式，同时也可能会包含其他的表达式。比如，如果case表达式是包含了接收表达式的短变量声明时，那么在赋值符号左边的就可以是一个或两个表达式，不过此处的表达式的结果必须是可以被赋值的。当这样的case表达式被求值时，它包含的多个表达式总会以从左到右的顺序被求值。  

- select语句包含的候选分支中的case表达式都会在该语句执行开始时先被求值，并且求值的顺序是依从代码编写的顺序从上到下的。结合上一条规则，在select语句开始执行时，排在最上边的候选分支中最左边的表达式会最先被求值，然后是它右边的表达式。仅当最上边的候选分支中的所有表达式都被求值完毕后，从上边数第二个候选分支中的表达式才会被求值，顺序同样是从左到右，然后是第三个候选分支、第四个候选分支，以此类推。  

- 对于每一个case表达式，如果其中的发送表达式或者接收表达式在被求值时，相应的操作正处于阻塞状态，那么对该case表达式的求值就是不成功的。在这种情况下，我们可以说，这个case表达式所在的候选分支是不满足选择条件的。  

- 仅当select语句中的所有case表达式都被求值完毕后，它才会开始选择候选分支。这时候，它只会挑选满足选择条件的候选分支执行。如果所有的候选分支都不满足选择条件，那么默认分支就会被执行。如果这时没有默认分支，那么select语句就会立即进入阻塞状态，直到至少有一个候选分支满足选择条件为止。一旦有一个候选分支满足选择条件，select语句（或者说它所在的 goroutine）就会被唤醒，这个候选分支就会被执行。  

- 如果select语句发现同时有多个候选分支满足选择条件，那么它就会用一种伪随机的算法在这些分支中选择一个并执行。注意，即使select语句是在被唤醒时发现的这种情况，也会这样做。  

- 一条select语句中只能够有一个默认分支。并且，默认分支只在无候选分支可选时才会被执行，这与它的编写位置无关。  

- select语句的每次执行，包括case表达式求值和分支选择，都是独立的。不过，至于它的执行是否是并发安全的，就要看其中的case表达式以及分支中，是否包含并发不安全的代码了。  


# 缓冲通道  
- 发送操作会使通道复制被发送的元素。若因通道的缓冲空间已满而无法立即复制，则阻塞进行发送操作的goroutine。复制的目的地址有两种。当通道已空且有接收方在等待元素值时，它会时最早等待的那个接收方的持有的内存地址，否则会是通道持有的缓冲中内存地址。  
- 接受操作会使通道给出一个已发给它的元素值的副本，若因通道的缓冲空间已空而无法立即给出，则阻塞进行接受操作的goroutine。一般情况下，接受方会从通道持有的缓冲中得到元素值。    
- 对于同一个元素值来说，把它发送给某个通道的操作，一定会在从该通道接受它的操作完成之前完成。换句话说，在通道完全复制一个元素值之前，任何goroutine都不可能从它那里接收到这个元素值的复制。  

# 空结构体
struct{}代表的是不包含任何字段的结构体类型，也可以称为空结构体类型，在go语言中，空结构体类型的变量是不占用内存空间的，并且所有该类型的变量都拥有相同的内存地址，建议用于传递"信号"的通道都以struct{}作为元素类型，除非传递更多的信息。  

# select的执行顺序
从左往右，自上而下的顺序，当有多个case语句符合时，只会随机挑选一个执行，如果都不符合的话就会执行默认的default语句，如果没有一个case语句符合且没有default语句时程序就会阻塞在哪里，如果只有一个goroutine时就会发生死锁，所以要避免写出这样的代码。