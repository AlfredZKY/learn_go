# 同步的用途
go用通讯的方式共享数据
问题：一旦数据被多个线程共享，那么就可能会产生争用和冲突的情况，这种情况被称为竞态条件，往往会破坏共享数据的一致性
- 避免多个线程在同一时刻操作同一个代码块
- 协调多个线程，以避免它们在同一时刻执行同一个代码块

# 互斥锁的使用事项
- 不要重复锁定互斥锁,当重复使用同一个互斥锁锁定的goroutine会被阻塞，直到有解锁之后，阻塞的goroutine才能被唤醒并执行 对一个已经锁定的互斥锁进行锁定，是会立即阻塞当前的goroutine的，这个goroutine所执行的流程，会一直停滞在调用该互斥锁的Lock方法的哪行代码上
- 不要忘记解锁互斥锁，必要时使用defer语句
- 不要对尚未锁定或者已解锁的互斥锁解锁
- 不要在多个函数之间直接传递互斥锁

# 函数中不可以传入一个互斥锁做参数
如果你把一个互斥锁作为参数值传给了一个参数，那么在这个函数中对传入的锁的所有操作，都不会对存在于该函数之外的那个原锁产生任何影响  

# go中的死锁
所谓的死锁，指的就是当前程序中的主 goroutine，以及我们启用的那些 goroutine 都已经被阻塞。这些 goroutine 可以被统称为用户级的 goroutine。这就相当于整个程序都已经停滞不前了。  

Go 语言运行时系统是不允许这种情况出现的，只要它发现所有的用户级 goroutine 都处于等待状态，就会自行抛出一个带有如下信息的 panic：fatal error: all goroutines are asleep - deadlock!    
<font color = '#ff0000'>注意，这种由 Go 语言运行时系统自行抛出的 panic 都属于致命错误，都是无法被恢复的，调用recover函数对它们起不到任何作用。也就是说，一旦产生死锁，程序必然崩溃。</font>  

# 临界区
    多个并发运行的线程对于这个共享资源的访问完全是串行的，只要一个代码片段需要实现对共享资源的串行化访问，就可视为临界区

# 同步工具之互斥锁
    它们可以是一个内含了共享数据的结构体及其方法，也可以是操作同一块共享数据的多个函数，临界区总是需要受到保护的，否则就会产生竟态条件，施加保护的重要手段，就是使用实现了某种同步机制的工具，也成同步工具  
    sync/mutex 一个互斥锁可以被用来保护一个临界区或者一组相关临界区，通过它来保证在同一时刻只有一个goroutine处于该临界区内


# 读写锁与互斥锁有哪些异同
读写锁是读/写互斥锁的简称，在go中读写锁由sync.RWMutex类型的值代表，与sync.Mutex一样，也是开箱即用。  
顾名思义，读写锁是把共享资源的"读操作"和"写操作"区别对待了，它可以对这两种操作施加不同程度的保护，换句话说，相比于互斥锁，读写锁可以实现更加细腻的控制访问。  
一个读写锁实际上包含了两个锁，即:读锁和写锁。sync.RWMutex类型中Lock方法和UnLock方法分别用于对写锁进行锁定和解锁，而它的RLock方法和RUnlock方法则分别用于对读锁进行锁定和解锁。另外，对于同一个读写锁来说有如下规则： 
- 在写锁已被锁定的情况下再试图锁定写锁，会阻塞当前的goroutine
- 在写锁已被锁定的情况下试图锁定读锁，会阻塞当前的goroutine
- 在读锁已被锁定的情况下试图锁定写锁，同样会阻塞当前的goroutine
- 在读锁已被锁定的情况下再试图锁定读锁，并不会阻塞当前的goroutine
换个角度来说就是，对于某个受到读写锁保护的共享资源，多个写操作不能同时进行，写操作和读操作也不能同时进行，但多个读操作却可以同时进行。  

对写锁进行解锁时，会唤醒"所有因试图锁定读锁，而被阻塞的goroutine"，并且，这通常会使他们都成功完成对读锁的锁定  

对读锁进行解锁，只会在没有其他读锁锁定前提下，唤醒"因试图锁定写锁，而被阻塞的goroutine"，并且最终只有一个会被唤醒的goroutine能够成功完成对写锁的锁定，其他的goroutine还要在原处继续等待，至于是哪一个goroutine，那就要看谁的等待时间最长了

写解锁会试图唤醒所有因欲进行读锁定而被阻塞的goroutine，而读解锁只会已无任何读锁定的情况下，试图唤醒一个因欲进行写锁定而被阻塞的goroutine。  

对于同一个读写锁来说，施加于其上的读锁定可以有多个，因此只有对互斥锁进行等量的读解锁，才能够让某一个写锁定获得进行的机会，否则就会使欲进行写锁定的goroutine一直处于阻塞状态  
