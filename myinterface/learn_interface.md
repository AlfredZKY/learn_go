# go接口
在Go语言中，接口一定是指的是接口类型，因为接口类型与其他数据类型不同，它是没法被值化的，或者是说没法被实例化的。更具体地说我们既不能通过调用new函数或make函数创建出一个接口类型的值，也无法用字面来表示一个接口类型的值
对于任何数据类型，只要它的方法集合中完全包含了一个接口的全部特征(即全部方法)，那么它就一定是这个接口的实现类型这种方式称为无侵入的接口类型实现方式。即Duck typing 鸭子类型

# 怎样判定一个数据类型的某一个方法实现的就是某个接口类型中的方法？
- 两个方法的签名需要完全一致
- 两个方法的名称要一模一样

对于一个接口类型的变量来说，我么赋给它的值可以直接被叫做它的实际值(也称为动态值)，而该值的类型可以被叫做这个变量的实际类型(也称为动态类型)
如我们把取地址表达式&dog的结果值赋给了接口变量pet,这时这个结果值就是变量pet的动态值，而此结果值的类型*Dog就是该变量的动态类型。
动态类型这个叫法就是相对于静态类型而言的，对于变量pet来讲，它的静态类型就是Pet，并且永远是Pet,但它的动态类型却会随着我们赋给它的的动态值而变化。

# iface结构
当我们给一个接口变量赋值的时候，该变量的动态类型会与它的动态值一起被存到一个专用的数据结构中，这样一个变量的值其实是这个专用数据结构的一个实例，而不是我们赋值给变量的那个实际的值。
iface实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用他们的途径。
总之，接口变量被赋予动态值的时候，存储的是包含了这个动态值的副本的一个结构更加复杂的值。

记住:除非我们只声明而不初始化，或者显式地赋给它nil，否则接口变量的值就不会为nil